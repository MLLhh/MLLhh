虽然添加了获取IP和设置端口的代码
但为了测试方便，套接字直接绑定了指定的IP和端口
运行代码需要修改C/S的bind()和writeDatagram（）的参数为自己的IP


发送端代码思路：
头文件：
声明结构体变量
构造函数中会初始化用于表示分包数据的变量

数据初始化：
1.MainWindow构造函数
  创建socket套接字
  关联发送按钮和定时器函数
  关联停止发送按钮和关闭定时器函数
  关联时钟信号和发包函数
  关联设备读取和IP显示函数//暂时没用上
2.UdpImgSocket构造函数
  初始化私有成员变量，初始化：不含包头的数据大小、包头字节数、两相邻包间的发送间隔，减少丢包

功能函数：
1.点击启动，关联到定时器启动函数，开启定时器
2.关联定时器周期信号和发包函数
2.发包函数中调用socket数据发送函数writeDatagram
3.在writeDatagram（）中判断数据大小是否符合分包要求
   符合：计算分包数量
            记录包信息到包头结构体变量中，比如包头大小、分包数量、整包数据大小
            按分包数量进行分包（凭分包数量循环）：
                                          在每次循环中记录当前数据包偏移量以备读取数据包指定位置的数据
                                          计算本次分包要分配的数据量：
                                                                                     要么指定大小的数据量，比如拆成500一个包
                                                                                     要么不足500，当作一个包发送
                                          把拆好的包添加包头，用一个新的数组存储包头和指定偏移量开始的数据                                          
                                          调用socket发送函数发送数据包
                                          每个分片发出后线程睡眠X微秒，使相邻数据分片之间存在时间间隔，减少丢包
不符合：直接返回；

接收代码思路：
头文件：
1.包头结构体中记录下次组包的偏移量
   组包结构体写一个组包函数：
                                          如果包头结构体中存储的偏移量已经超过了包大小，则报错返回
                                          否则进行组包，并根据分包数量判断是否接收完

数据初始化：
1.MainWindow构造函数
  创建socket套接字
  关联启动按钮和监听函数
  关联结束按钮和停止监听函数
  关联socket读信号与socket读取函数

2.UdpImgSocket构造函数
  初始化私有成员变量，初始化:超时时间、互斥锁、待处理数据、超时检测器
  QList<PackageStatus> *m_pend_data;作为互斥共享变量被数据读取函数和超时检测函数共同访问，里面存放接收到的数据分片；
  

功能函数：
1.点击启动按钮套接字将绑定到指定IP和端口开始监听
   点击结束按钮停止监听
   当套接字有数据可以读取时，执行读取函数

2.数据读取函数：
                       读取要处理的字节数记录下来，申请这个大小的内存
                       读数据，并根据分片函数（isFragmented）判断这个包是不是分片
                       是分片：
                                  创建一个包头变量，用复制包头函数（headParser）保存数据中的包头到新建的包头变量中
                                  上锁
                                   将一段时间内的数据包添加到QList<PackageStatus>中
                                   在QList<PackageStatus>中搜索同一组的数据进行拼接
                                   组包成功将返回数据包长度
                                
3.超时检测函数（位于单独线程下）：
                        上锁
                        不停检测QList<PackageStatus>中是否有数据
                         有数据就记录下每组数据包的首包接收时间
                         如果有哪一组的首包已经是m_sleep_millisecond前接收的数据，就认为超时接收清理掉它                        
                         解锁
